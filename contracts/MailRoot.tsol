pragma ever-solidity ^0.62.0;

pragma AbiHeader expire;
pragma AbiHeader pubkey;


import "@broxus/ever-contracts/contracts/utils/RandomNonce.tsol";
import "@broxus/ever-contracts/contracts/access/abstract/Ownable.tsol";
import "@broxus/ever-contracts/contracts/upgrade/abstract/Upgradable.tsol";
import "./Mail.tsol";

import "./libraries/Errors.tsol";
import "./libraries/Gas.tsol";
import "./libraries/DexPlatformTypes.tsol";
import "./libraries/DexPlatformUtils.tsol";

import "./interfaces/IMailAccount.tsol";
import "./interfaces/IMailRoot.tsol";

import "./structures/IMailState.tsol";
import "./structures/IVersions.tsol";

contract MailRoot is Ownable, Upgradable, RandomNonce, IMailRoot, IMailState {
    TvmCell public _platformCode;

    VersionedCode _accountCode;
    VersionedCode _mailBoxCode;
    VersionedCode _mailCode;
    uint32 public _mailCount = 0;

    uint32 _mailNonce = 0;
    mapping (uint32 => PendingMail) _pendingMails;
    uint128 constant CONTRACT_MIN_BALANCE = 1 ever;
    uint128 constant FIXED_COMMISSION = 0.03 ever;

    constructor (
        address owner_,
        TvmCell platformCode_,
        TvmCell accountCode_,
        TvmCell mailBoxCode_,
        TvmCell mailCode_
    ) public {
        require (tvm.pubkey() != 0, Errors.WRONG_PUBKEY);
        require (tvm.pubkey() == msg.pubkey(), Errors.WRONG_PUBKEY);
        tvm.accept();

        _setOwnerInternal(owner_);

        _setPlatformCodeInternal(platformCode_);
        _setAccountCodeInternal(accountCode_);
        _setMailBoxCodeInternal(mailBoxCode_);
        _setMailCodeInternal(mailCode_);
    }

    function _setPlatformCodeInternal(TvmCell _code) internal {
        _platformCode = _code;

        emit PlatformCodeUpdated(_getCodeInfo(_code));
    }

    function _setAccountCodeInternal(TvmCell _code) internal {
        CodeInfo info = _getCodeInfo(_code);

        _accountCode = VersionedCode({
            code: _code,
            version: _accountCode.version + 1,
            info: info
        });

        emit AccountCodeUpdated(info);
    }

    function _setMailBoxCodeInternal(TvmCell _code) internal {
        CodeInfo info = _getCodeInfo(_code);

        _mailBoxCode = VersionedCode({
            code: _code,
            version: _mailBoxCode.version + 1,
            info: info
        });

        emit MailBoxCodeUpdated(info);
    }

    function _setMailCodeInternal(TvmCell _code) internal {
        CodeInfo info = _getCodeInfo(_code);

        _mailCode = VersionedCode({
            code: _code,
            version: _mailCode.version + 1,
            info: info
        });

        emit MailCodeUpdated(info);
    }

    function _getCodeInfo(TvmCell _code) internal pure returns (CodeInfo) {
        return CodeInfo({
            hash: tvm.hash(_code),
            depth: _code.depth()
        });
    }

    function _getTargetBalanceInternal()
        internal
        view
        override
        returns (uint128)
    {
        return math.max(address(this).balance - (msg.value - FIXED_COMMISSION), CONTRACT_MIN_BALANCE);
    }

    function getAccountCode()
        external
        view
        override
        responsible
        returns (VersionedCode)
    {
        return {
            value: 0,
            flag: MsgFlag.REMAINING_GAS,
            bounce: false
        } _accountCode;
    }

    function setAccountCode(TvmCell _code)
        external
        override
        reserveAndRefund(_getTargetBalanceInternal(), msg.sender, msg.sender)
        onlyOwner
    {
        _setAccountCodeInternal(_code);
    }

    function _deployMail(
        MailUser[] receivers,
        bytes encryptedMail,
        bytes senderMeta,
        bytes[] receiverMeta,
        uint16 metaVersion
    ) internal returns (address mail) {
        _mailCount += 1;
        mail = new Mail{
            stateInit: _buildMailInitData(_mailCount),
            value: Gas.MAIL_DEPLOY_VALUE,
            flag: MsgFlag.SENDER_PAYS_FEES
        }(encryptedMail, msg.sender);
        emit MailCreated(receivers, encryptedMail, senderMeta, receiverMeta, metaVersion, msg.sender, mail);
    }

    function _saveOutMail(address mail, bytes meta, uint16 metaVersion, address send_gas_to) internal {
        address sender_mail_account = getMailAccountAddress(MailUser(msg.sender, 0));
        _mailNonce += 1;
        _pendingMails[_mailNonce] = PendingMail(MailUser(msg.sender, 0), mail, meta, msg.sender, metaVersion, send_gas_to);
        IMailAccount(sender_mail_account).saveOutMailAddress{value: Gas.SAVE_MAIL_VALUE, flag: MsgFlag.SENDER_PAYS_FEES}(_mailNonce, mail, meta, metaVersion);
    }

    function _saveInMail(MailUser user, address mail, bytes meta, uint16 metaVersion, address send_gas_to) internal {
        address receiver_mail_account = getMailAccountAddress(user);
        _mailNonce += 1;
        _pendingMails[_mailNonce] = PendingMail(user, mail, meta, msg.sender, metaVersion, send_gas_to);
        IMailAccount(receiver_mail_account).saveInMailAddress{value: Gas.SAVE_MAIL_VALUE, flag: MsgFlag.SENDER_PAYS_FEES}(_mailNonce, mail, meta, msg.sender, metaVersion);
    }

    function sendMails(
        MailUser[] receivers,
        bytes encryptedMail,
        bytes senderMeta,
        bytes[] receiverMeta,
        uint16 metaVersion,
        address send_gas_to
    ) external reserveAndRefund(_getTargetBalanceInternal(), send_gas_to, msg.sender) {
        require (receivers.length == receiverMeta.length, Errors.BAD_INPUT);
        require (msg.value >= Gas.MAIL_DEPLOY_VALUE + FIXED_COMMISSION + Gas.SAVE_MAIL_VALUE * receivers.length + 0.01 ever * receivers.length, Errors.LOW_MSG_VALUE);

        address mail = _deployMail(receivers, encryptedMail, senderMeta, receiverMeta, metaVersion);
        _saveOutMail(mail, senderMeta, metaVersion, send_gas_to);

        for (uint i = 0; i < receivers.length; i++) {
            MailUser _user = receivers[i];
            require (_user.pubkey == 0 || _user.addr == address.makeAddrStd(address(this).wid, 0), Errors.BAD_INPUT);

            _saveInMail(_user, mail,receiverMeta[i], metaVersion, send_gas_to);
        }
    }

    function onMailSaved(uint32 nonce)
        external
        override
        reserve(_getTargetBalanceInternal())
    {
        PendingMail _mail = _pendingMails[nonce];
        address mail_acc = getMailAccountAddress(_mail.user);

        require (msg.sender == mail_acc, Errors.NOT_MAIL_ACC);

        delete _pendingMails[nonce];
        _mail.send_gas_to.transfer({ value: 0, bounce: false, flag: MsgFlag.ALL_NOT_RESERVED });
    }

    function getMailAccountAddress(MailUser user) public view responsible returns (address) {
        return {
            value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false
        } DexPlatformUtils.expectedMailAccount(address(this), _platformCode, user);
    }

    function _deployMailAccount(MailUser receiver, address send_gas_to) internal view returns (address) {
        return new DexPlatform{
            stateInit: DexPlatformUtils.buildInitData(
                address(this),
                _platformCode,
                DexPlatformTypes.MailAccount,
                DexPlatformUtils.buildMailAccountParams(receiver)
            ),
            value: Gas.ACCOUNT_DEPLOY_VALUE,
            flag: MsgFlag.SENDER_PAYS_FEES
        }(
            _accountCode.code,
            _accountCode.version,
            send_gas_to,
            abi.encode(_mailBoxCode)
        );
    }

    function _buildMailInitData(uint128 _nonce) internal view returns (TvmCell) {
        return tvm.buildStateInit({
            contr: Mail,
            varInit: {
                root: address(this),
                nonce: _nonce
            },
            pubkey: 0,
            code: _mailCode.code
        });
    }

    function getMailAddress(uint128 _nonce) public view responsible returns (address) {
        return { value: 0, flag: MsgFlag.REMAINING_GAS, bounce: false } address(
            tvm.hash(_buildMailInitData(_nonce))
        );
    }

    function withdrawCommission()
        external
        view
        onlyOwner
        reserveAndRefund(CONTRACT_MIN_BALANCE, _getOwnerInternal(), msg.sender) {}

    onBounce(TvmSlice slice) external view {
        tvm.accept();

        uint32 functionId = slice.decode(uint32);
        // if processing failed - contract was not deployed. Deploy and try again
        if (functionId == tvm.functionId(IMailAccount.saveOutMailAddress)) {
            tvm.rawReserve(_getTargetBalanceInternal(), 0);

            uint32 _nonce = slice.decode(uint32);
            PendingMail _mail = _pendingMails[_nonce];
            address mail_acc = _deployMailAccount(_mail.user, _mail.send_gas_to);

            IMailAccount(mail_acc).saveOutMailAddress{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                _nonce, _mail.mail, _mail.meta, _mail.metaVersion
            );
        } else if (functionId == tvm.functionId(IMailAccount.saveInMailAddress)) {
            tvm.rawReserve(_getTargetBalanceInternal(), 0);

            uint32 _nonce = slice.decode(uint32);
            PendingMail _mail = _pendingMails[_nonce];
            address mail_acc = _deployMailAccount(_mail.user, _mail.send_gas_to);

            IMailAccount(mail_acc).saveInMailAddress{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                _nonce, _mail.mail, _mail.meta, _mail.sender, _mail.metaVersion
            );
        }
    }

    function upgradeMailAccounts(
        address[] _accounts,
        uint32 _offset,
        address _remainingGasTo
    )
        external
        view
        override
        onlyOwner
        reserve(_getTargetBalanceInternal())
    {
        uint length = _accounts.length;
        uint takeUntil = math.min(_offset + 5, length);

        for (uint i = _offset; i < takeUntil; i++) {
            _upgradeAccountInternal(_accounts[i], _remainingGasTo);
        }

        if (takeUntil < length) {
            IMailRoot(address(this))
                .upgradeMailAccounts{
                    value: 0,
                    flag: MsgFlag.ALL_NOT_RESERVED,
                    bounce: false
            }(_accounts, uint32(takeUntil), _remainingGasTo);
        } else {
            _remainingGasTo.transfer({
                value: 0,
                flag: MsgFlag.ALL_NOT_RESERVED + MsgFlag.IGNORE_ERRORS,
                bounce: false
            });
        }
    }

    function _upgradeAccountInternal(
        address _account,
        address _remainingGasTo
    ) private view {
        emit UpgradeAccount(_account, _accountCode.version);

        IMailAccount(_account)
            .upgrade{
                value: 0.2 ever,
                flag: MsgFlag.SENDER_PAYS_FEES,
                bounce: false
        }(
            _accountCode.code,
            _accountCode.version,
            _remainingGasTo
        );
    }

    function upgrade(
        TvmCell _code,
        optional(uint32) _version,
        optional(address) _remainingGasTo
    )
        external
        override
        onlyOwner
        reserveAndRefund(_getTargetBalanceInternal(), _remainingGasTo, msg.sender)
    {
        uint32 currentVersion = _getCurrentVersionInternal();
        IVersions.Versions versions = IVersions.Versions({
            current: _version.hasValue() ? _version.get() : currentVersion + 1,
            previous: currentVersion
        });

        TvmCell data = abi.encode(
            versions,

            _accountCode,
            _mailBoxCode,
            _mailCode,
            _mailCount,
            _getOwnerInternal(),

            _mailNonce,
            _pendingMails
        );

        tvm.setcode(_code);
        tvm.setCurrentCode(_code);

        onCodeUpgrade(data);
    }

    function onCodeUpgrade(TvmCell _data) private {
        tvm.resetStorage();

        address owner;
        IVersions.Versions versions;
        (
            versions,

            _accountCode,
            _mailBoxCode,
            _mailCode,
            _mailCount,
            owner,

            _mailNonce,
            _pendingMails
        ) = abi.decode(_data, (
            IVersions.Versions,

            VersionedCode,
            VersionedCode,
            VersionedCode,
            uint32,
            address,

            uint32,
            mapping(uint32 => PendingMail)
        ));

        _setOwnerSilent(owner);
        _setCurrentVersionInternal(versions.current, versions.previous);
    }
}
